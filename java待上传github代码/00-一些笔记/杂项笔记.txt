用tomcat测试发现，只要cookies里JSESSIONID一样，就会被服务器认为是同一个session。
（session的地址一样，且对一个session设置attri，另一个id一样的session能访问该值。


上下文的attri，任何访问都能看到


==================================================================================

增强某个方法，有三种方法：
1，知道方法的类。直接用继承重写；
2，不知道类，知道接口且接口只有少数方法。用修饰器；
3，用动态代理。下面的代码是用filter增强getParameter，使其解决utf8乱码

public void doFilter(ServletRequest r1, ServletResponse s, FilterChain chain) throws IOException, ServletException {
		HttpServletRequest r = (HttpServletRequest) r1;
		HttpServletRequest r2 = (HttpServletRequest) Proxy.newProxyInstance(
				r.getClass().getClassLoader(),
				r.getClass().getInterfaces(), 
				new InvocationHandler() {
					@Override
					public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
						if ("getParameter".equalsIgnoreCase(method.getName())) {
							String m = r.getMethod();
							if ("get".equalsIgnoreCase(m) || "post".equalsIgnoreCase(m)) {
								String a = (String) method.invoke(r, args);
								if (a != null) {
									a = new String(a.getBytes("iso-8859-1"), "utf-8");
									return a;
								}
							}
						}
						return method.invoke(r, args);
					}
				});

		chain.doFilter(r2, s);
	}


==================================================================================



配置文件模板在
资料\spring-framework-4.2.4.RELEASE-dist\spring-framework-4.2.4.RELEASE\docs\spring-framework-reference\html


==================================================================================


07stores里有ajax中文乱码的解决方法

bean里写了带参数的构造方法就一定要写无参的！！不然BeanListHandler无法构造bean，bug都找不到




==================================================================================





default.properties在Web App Libraries/struts2-core-2.3.24.jar/org.apache.struts2/default.properties

覆盖加载：

方法1（推荐）：  在struts2.xml里设置	 ，比如：
<constant name="struts.action.extension" value="action"></constant>


方法2： 在web.xml的filter里设置init-param,比如：
  <filter>
  	<filter-name>struts2</filter-name>
  	<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
  	<init-param>
  		<param-name>struts.action.extension</param-name>
  		<param-value>xyz</param-value>
  	</init-param>
  </filter>


===========================================================================================

	<package name="A" extends="struts-default" namespace="/">
		<interceptors>
			<interceptor name="i1" class="com.interception.I1"></interceptor>
			<interceptor name="i2" class="com.interception.I2"></interceptor>			
		</interceptors>		


		<action name="a_*" class="com.action.A"  method="a{1}">
			<result  name="login">/1.jsp</result>
			<result name="zhucefailed">/WEB-INF/3.jsp</result>
			<result name="zhucesuccess">/WEB-INF/3.jsp</result>			
			<result name="index">/index.jsp</result>
			<result name="fff">/WEB-INF/2.jsp</result>
			<result type="redirectAction">a_f</result>

			<interceptor-ref name="i1">
				 <param name="excludeMethods">a1,a2</param>
			</interceptor-ref>
			<interceptor-ref name="i2"></interceptor-ref>
			<interceptor-ref name="defaultStack"></interceptor-ref>
		</action>	
	</package>
  
  直接使用redirect的方法无法访问web-inf下面的页面，可以用redirectAction重定向，
  然后在相应的地方用请求转换的方法跳转web-inf下面的页面
  
  
  
==================================================================================

ctrl+shift+L可以补全=左边的变量

==================================================================================


在项目的hibernate的配置文件hibernate.cfg.xml里修改name为“hibernate.connection.url"的property的值为：
          jdbc:mysql://localhost:3306/tdm?useUnicode=true&amp;characterEncoding=UTF-8，其中tdm为数据库的名称
		  

==================================================================================

hql语句_直接查询数组里的id
public interface ContractProductDao extends JpaRepository<ContractProduct, String>,JpaSpecificationExecutor<ContractProduct>{
	@Query(countQuery="select * from contractproduct_p where contract_id=?")
	public List<ContractProduct> findByContractId(String i);
	
	@Query(value="from ContractProduct where to_char(contract.shipTime,'yyyy-MM') = ?1")
	public List<ContractProduct> findCpByShipTime(String shipTime);
	
	//根据购销合同id集合一次性查询购销合同货物
	@Query(value="from ContractProduct where contract.id in (?1)")
	public List<ContractProduct> findCpByContractIds(String[] ids);
}

===========================================================================================

1、pageEncoding="UTF-8"的作用是设置JSP编译成Servlet时使用的编码。 
2、contentType="text/html;charset=UTF-8"的作用是指定对服务器响应进行重新编码的编码。 
3、request.setCharacterEncoding("UTF-8")的作用是设置对客户端请求进行重新编码的编码。
4、response.setCharacterEncoding("UTF-8")的作用是指定对服务器响应进行重新编码的编码。 
response.setCharacterEncoding("UTF-8")的作用是指定对服务器响应进行重新编码的编码。同时，浏览器也是根据这个参数来对其接收到的数据进行重新编码（或者称为解码）。所以在无论你在JSP中设置response.setCharacterEncoding ("UTF-8")或者response.setCharacterEncoding("GBK")，浏览器均能正确显示中文（前提是你发送到浏览器的数据编码是正确的，比如正确设置了pageEncoding参数等）。

 

对于发送数据，服务器按照response.setCharacterEncoding—contentType—pageEncoding的优先顺序，对要发送的数据进行编码。 

对于接收数据，要分三种情况。一种是浏览器直接用URL提交的数据，另外两种是用表单的GET和POST方式提交的数据。

 

对于表单中POST方式提交的数据，只要在接收数据的JSP中正确request.setCharacterEncoding参数，即将对客户端请求进行重新编码的编码设置成浏览器编码，就可以保证得到的参数编码正确。有写读者可能会问，那如何得到浏览器编码呢？上面我们提过了，在默认请情况下，浏览器编码就是你在响应该请求的JSP页面中response.setCharacterEncoding设置的值。所以对于POST表单提交的数据，在获得数据的JSP页面中request.setCharacterEncoding要和生成提交该表单的JSP页面的 response.setCharacterEncoding设置成相同的值。 

对于URL提交的数据和表单中GET方式提交的数据，在接收数据的JSP中设置request.setCharacterEncoding参数是不行的，因为在Tomcat5.0中，默认情况下使用ISO- 8859-1对URL提交的数据和表单中GET方式提交的数据进行重新编码（解码），而不使用该参数对URL提交的数据和表单中GET方式提交的数据进行重新编码（解码）。要解决该问题，应该在Tomcat的配置文件的Connector标签中设置useBodyEncodingForURI或者 URIEncoding属性，其中useBodyEncodingForURI参数表示是否用request.setCharacterEncoding 参数对URL提交的数据和表单中GET方式提交的数据进行重新编码，在默认情况下，该参数为false（Tomcat4.0中该参数默认为true）； URIEncoding参数指定对所有GET方式请求（包括URL提交的数据和表单中GET方式提交的数据）进行统一的重新编码（解码）的编码。 URIEncoding和useBodyEncodingForURI区别是，URIEncoding是对所有GET方式的请求的数据进行统一的重新编码（解码），而useBodyEncodingForURI则是根据响应该请求的页面的request.setCharacterEncoding参数对数据进行的重新编码（解码），不同的页面可以有不同的重新编码（解码）的编码。所以对于URL提交的数据和表单中GET方式提交的数据，可以修改 URIEncoding参数为浏览器编码或者修改useBodyEncodingForURI为true，并且在获得数据的JSP页面中 request.setCharacterEncoding参数设置成浏览器编码。


--------------------- 
作者：fancylovejava 
来源：CSDN 
原文：https://blog.csdn.net/fancylovejava/article/details/7700683 
版权声明：本文为博主原创文章，转载请附上博文链接！

=============================================================================

右键项目名称,web deployment assembly，add-->java build path entries，
每次在maven里update project都要重复这个操作。
=============================================================================
jsp和java似乎无法直接获取浏览器的地址栏里的地址，可以用$(location)[0].href获取

=============================================================================
使用filter拦截请求，被拦截的请求早请求转发或者重定向后必须return，否则可能出现奇怪的bug：
Cannot call sendRedirect() after the response has been committed 。

=============================================================================
必须在bean里设置set方法，dbutils里面的beanhandler方法才能设置相应的值。

=============================================================================
redis可以直接用get和set保存获取json。比如用beanlisthandler从mysql获取的数据，用gson转成json后可以直接保存。
因为json本身就是String

=============================================================================
a的aid是b的bid的外键，可以在javabean给a额外设置一个属性ab，类型b。dao里获取a后，再a.setAb即可获得b的属性。
一A对多B的关系，例如类别对商品，可以在A里添加属性List<B> lb=new List<B>，然后在B里添加A a，
这样需要跨表查数据时可以封装在一个对象里传输，不需要时不封装即可。多对多可以在类里封装对方的list

=============================================================================
设置a标签无效，
href=""
a.disabled {
    pointer-events: none;
}


=============================================================================
 1. jQuery AJAX 请求,后台收到为乱码
可以显式设置contentType的编码为utf-8, 后台一般都能正常解码例如：
contentType: "application/x-www-form-urlencoded; charset=utf-8", 
 
jQuery(form).ajaxSubmit({url: "doLogin?user=a",type: "post",dataType: "json",
      contentType: "application/x-www-form-urlencoded; charset=utf-8",success: showLoginResponse});  

如果不加contentType: "application/x-www-form-urlencoded; charset=UTF-8",  而使用escape(),则会出现
post 主体包含的字节比内容长度指定的字节要少
的错误.
 
2.  jQuery AJAX 返回乱码
你是否发现无论你怎么设置编码, 客户端收到的数据总是乱码呢, 请看下面的例子,你发现有什么问题吗?
void saveTempKind(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException {  
PrintWriter pw = resp.getWriter(); resp.setContentType("text/text;charset=GBK");  
try {  //DO PROCESS   pw.write("成功"); }catch(Exception e){  pw.write("失败"); }}  
问题在于resp.setContentType("text/text;charset=GBK");
语句应该在
PrintWriter pw = resp.getWriter();

之前,而不是之后。如果象上例这样，无论你怎么设置response的编码，前端乱码的问题都依然如故。 可能的原因是pw在获得PriintWriter 之前,编码就已经确定了。
所以编码的声明应该在获取PrintWriter对象之前。

本文来自 hongweigg 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/hongweigg/article/details/6756278?utm_source=copy 


==========================================================================================================================================================

导入jsp-api的包，在jsp文件前面加上
<%@taglib prefix="s" uri="/struts-tags" %>

遍历语法如下：
 		<s:iterator value="lc" var="b">
 
				<s:property value="#b.cust_name"/>
   		</s:iterator> 
		
貌似domain的类一般都实现serializable接口。

=============================================================================

持久化类要遵循JavaBean的规范：
⑴ JavaBean 必须放在一个单独的包中
⑵ JavaBean 必须申明为 public class 即：必须是公有的类
⑶ JavaBean 的所有属性必须申明为 private 即：属性必须私有
⑷ 通过公有的 setter 方法和 getter 方法设值和取值    
⑸ 必须有一个公有无参构造方法
⑹ 编写代码要严格遵守 Java 程序的命名规范（这个不必须）
(7)必须提供一个OID作为主键（一般是long属性）
(8)最好使用包装类（int->Integer)
(9)不能用final修饰
(10)实现serializable接口。因为可能要读写到硬盘（钝化活化）。

生成数据库表时的默认值
基本类型：int 0
包装类：integer null

==============================================================================

domain的类写在dao层的java，然后在dao层的resouces同样的路径下hbm.xml，
例如Customer.java在src/main/java/cn/domain，
那么Custoemr.hbm.xml在src/main/resouces/cn/domain，否则会报错。

=============================================================================