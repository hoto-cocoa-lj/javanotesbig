ioc(控制反转)要导的包：4个
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-beans</artifactId>
		<version>4.2.4.RELEASE</version>
	</dependency>
	
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-context</artifactId>
		<version>4.2.4.RELEASE</version>
	</dependency>
	
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-core</artifactId>
		<version>4.2.4.RELEASE</version>
	</dependency>
	
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-expression</artifactId>
		<version>4.2.4.RELEASE</version>
	</dependency>

================================================================
	
日志包：2个(只导上面4个不导日志包容易报错)
	<dependency>
		<groupId>org.apache.commons</groupId>
		<artifactId>com.springsource.org.apache.commons.logging</artifactId>
		<version>1.1.1</version>
	</dependency>
	
	<dependency>
		<groupId>org.apache.log4j</groupId>
		<artifactId>com.springsource.org.apache.log4j</artifactId>
		<version>1.2.15</version>
	</dependency>

================================================================

ioc使用注解：1个包
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-aop</artifactId>
		<version>4.2.4.RELEASE</version>
	</dependency>

================================================================
	
spring整合junit测试：3个包(spring-test  junit  spring-aop)
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-test</artifactId>
		<version>4.2.2.RELEASE</version>
	</dependency>
	<dependency>
		<groupId>junit</groupId>
		<artifactId>junit</artifactId>
		<version>4.9</version>
	</dependency>
		<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-aop</artifactId>
		<version>4.2.4.RELEASE</version>
	</dependency>

================================================================
	
aop(面向切面编程)要导的包：4个(aop联盟  spring-aop  aspects  spring-aspects)
spring-aop实现了aop的规范，效果不好，aspects实现效果好，纳入
		<dependency>
			<groupId>org.aopalliance</groupId>
			<artifactId>com.springsource.org.aopalliance</artifactId>
			<version>1.0.0</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-aop</artifactId>
			<version>4.2.4.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>org.aspectj</groupId>
			<artifactId>com.springsource.org.aspectj.weaver</artifactId>
			<version>1.6.8.RELEASE</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-aspects</artifactId>
			<version>4.2.4.RELEASE</version>
		</dependency>

		
aop的xml配置：更多的例子和全注解配置见  xml配置文件/spring的配置/aop代码
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop" 
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd   
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

	<!--使用这个配置aop的话，必须在相应的类的上配置@Component("z")等
	<context:component-scan base-package="com"></context:component-scan>
	-->	
	<bean id="ss" class="com.interception.SS"></bean>
	<bean id="z" class="com.interception.Z"></bean>		

	<aop:config>
		<aop:aspect ref="z">
			<!--给需要增强的方法设置引用ref，减少代码量，也可以不设置-->	
			<aop:pointcut expression="execution(* com.interception.SS.*(..))" id="all1"/>
			
			<!--最常用这个，void表示此方法没有返回值，用*表示可以更好，
			包括所有返回值和没有返回值。g(..)里的..表示任意参数-->
			<aop:after-returning method="af" pointcut="
			execution(void com.interception.SS.g())" /> 
			
			<!--常用这个，表示com.interception的所有子包的所有类的所有方法-->
			<aop:after method="md" pointcut="execution(* com.interception..*.*(..))" />
			
			<!--表示com.interception的类的所有方法-->
			<aop:after method="md" pointcut="execution(* com.interception.*.*(..))" />
			
			<!--表示com.interception的SS类的所有方法-->
			<aop:after method="md" pointcut="execution(* com.interception.SS.*(..))" /> 
			
			<!--表示com.interception的SS类的以g为第一个字面的方法-->
			<aop:around method="md" pointcut="execution(* com.interception.SS.g*(..))" />
			
			<!--使用pointcut引用的配置-->
			<aop:around method="md"  pointcut-ref="all1"/>
		</aop:aspect>
	</aop:config>
	<!-- before:之前，可以用权限拦截  after:之后执行，即使报错，类似finally after-returning:被增强方法不报错后执行，可用于日志输出 after-throwing:被增强方法报错后执行 
		around:在增强方法内部执行被增强方法，可用于性能检测 -->
</beans>

================================================================		

data access/integration：	jdbc/orm/oxm/jms/transactions

spring使用jdbc：事务spring-tx,spring-jdbc,加上ioc的包(这4个包spring项目必须)，
	jdbc的事务管理包是DataSourceTransactionManager，applicationContext.xml里需要配置datasource,jdbcTemplate(需要dataSource),transactionManager(需要dataSource),tx:annotation-driven(需要transactionManager),context:component-scan。

	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-tx</artifactId>
		<version>4.2.4.RELEASE</version>
	</dependency>
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-jdbc</artifactId>
		<version>4.2.4.RELEASE</version>
	</dependency>

(或者)使用hibernate：要导入hibernate的所有包
整合hibernate的包：1个spring-orm，HibernateTemplate在这个包，hibernate的事务
	管理包是HibernateTransactionManager，导错包的话操作数据库会自动回滚不保存，配制方法有两种，
	旧版使用sessionfactory，applicationContext.xml里需要配置datasource,sessionFactory(需要dataSource等),hibernateTemplate(需要sessionFactory),transactionManager(需要sessionFactory),tx:annotation-driven(需要transactionManager),context:component-scan。service层需要配置@Transactional
	新版使用entityManagerFactory，applicationContext.xml里需要配置datasource,entityManagerFactory(需要dataSource等),jpa:repositories,transactionManager(需要entityManagerFactory),tx:annotation-driven(需要transactionManager),context:component-scan。service层需要配置@Transactional
	
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-orm</artifactId>
		<version>4.2.4.RELEASE</version>
	</dependency>
	
使用hibernate在web层会遇到延迟加载报错no session的问题，解决方法有两个：
	1、所有1对多或者多对多都配置lazy=false，这样查询效率很低；	2、在web.xml里配置如下过滤器，作用是在过滤器中关闭session。配置的时候需要把这个过滤器的配置放在struts2等前端框架的过滤器之前，因为web.xml中的执行顺序是从上到下，回来的时候是从下往上关闭的。如果反过来，就会出现过滤器中关闭session了才在action里查询。

  <!-- 下面两个filter用来解决延迟加载问题的过滤器，放在web.xml里 -->
  <!-- LocalContainerEntityManagerFactoryBean使用这个-->
  <filter>
  	<filter-name>OpenSessionInViewFilter</filter-name>	<filter-class>org.springframework.orm.hibernate5.support.OpenSessionInViewFilter</filter-class>
  </filter> 
  
  <filter-mapping>
  	<filter-name>OpenSessionInViewFilter</filter-name>
  	<url-pattern>*.action</url-pattern>
  </filter-mapping>
  
    <!-- LocalSessionFactoryBean 使用这个 -->
	<filter>
		<filter-name>SpringOpenEntityManagerInViewFilter</filter-name>
		<filter-class>
			org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter
		</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>SpringOpenEntityManagerInViewFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	
================================================================
	
web(mvc/remoting)：    web/servlet/porlet/struts
整合web项目的包：1个
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-web</artifactId>
		<version>4.2.4.RELEASE</version>
	</dependency>

在web.xml里如下配置：spring加载时会加载contextConfigLocation的值指向的xml文件，
源码可以发现DEFAULT_CONFIG_LOCATION = "/WEB-INF/applicationContext.xml"，
是contextConfigLocation的默认值，需要修改

	<listener>							
		<listener-class>
			org.springframework.web.context.ContextLoaderListener
		</listener-class>
	</listener>
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:applicationContext.xml</param-value>
	</context-param>
	
================================================================	

整合struts的包：1个，作用是把action的创建交给spring(还有struts2自己的包)，
这个包里有这个配置<constant name='struts.objectFactory' value='spring' />
	<dependency>
		<groupId>org.apache.struts</groupId>
		<artifactId>struts2-spring-plugin</artifactId>
		<version>2.3.24</version>
	</dependency>
	
	需要在web.xml里struts2的配置做如下修改，加上init-param配置：
	  <filter>
	  	<filter-name>struts2</filter-name>
	  	<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
	  	<init-param>
	  		<param-name>struts.objectFactory</param-name>
	  		<param-value>spring</param-value>
	  	</init-param>
	  	<init-param>
	  			<param-name>struts.convention.package.locators</param-name>
	  			<param-value>web</param-value>
	  	</init-param>
	  </filter>
	  <filter-mapping>
			<filter-name>struts2</filter-name>
			<url-pattern>/*</url-pattern>
	  </filter-mapping>
	
================================================================

spring发邮件：1个
		<dependency>
		  <groupId>org.springframework</groupId>
		  <artifactId>spring-context-support</artifactId>
		  <version>4.2.4.RELEASE</version>
		</dependency>
需要配置xml，配置和详细代码见 spring的配置\配置文件\applicationContext-mail.xml
	
================================================================
	
================================================================	

================================================================	

================================================================	
================================================================	

================================================================	

================================================================	

================================================================	

================================================================	
================================================================	